<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF to Excel Converter — Storedropship</title>
  <meta name="description" content="Convert PDF tables and text to Excel (.xlsx) in the browser. Import PDF, extract tabular content with heuristics, preview and download .xlsx. Offline-capable; OCR not included." />
  <meta name="keywords" content="PDF to Excel, PDF table extraction, convert PDF to xlsx, PDF converter, extract tables from PDF" />
  <style>
    :root{--bg:#f7fafc;--card:#fff;--muted:#6b7280;--accent:#0ea5a4}
    *{box-sizing:border-box;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif}
    body{margin:0;background:linear-gradient(180deg,var(--bg),#eef2ff);padding:18px;color:#0f172a}
    .wrap{max-width:1100px;margin:0 auto}
    .card{background:var(--card);padding:16px;border-radius:12px;box-shadow:0 8px 30px rgba(10,20,40,0.06);margin-bottom:14px}
    h1{margin:0 0 6px;font-size:20px}
    p.lead{margin:0 0 12px;color:var(--muted)}
    label{display:block;font-size:13px;color:#374151;margin-top:8px}
    input,select,button,textarea{width:100%;padding:10px;border-radius:8px;border:1px solid #e6eef6;font-size:14px}
    .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
    button.primary{background:var(--accent);color:#fff;border:none;padding:10px;border-radius:8px;cursor:pointer}
    button.alt{background:#fff;border:1px solid #e6eef6;color:#0b5394;padding:10px;border-radius:8px}
    pre{background:#f8fafc;padding:12px;border-radius:8px;border:1px solid #e6e9ef;overflow:auto;max-height:320px;white-space:pre-wrap}
    .meta{font-size:13px;color:var(--muted);margin-top:8px}
    .row{display:grid;grid-template-columns:1fr 360px;gap:12px}
    @media(max-width:900px){.row{grid-template-columns:1fr}}
  </style>
  <!-- PDF.js and SheetJS (xlsx) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>PDF to Excel Converter</h1>
      <p class="lead">Convert PDF content into Excel (.xlsx) spreadsheets in your browser. The tool uses PDF.js to extract text and a simple layout heuristic to detect tabular data. Works best with digital PDFs that contain selectable text and clear column layouts.</p>

      <label for="pdfFile">Choose PDF file</label>
      <input id="pdfFile" type="file" accept="application/pdf" />

      <div class="row">
        <div>
          <label for="strategy">Extraction strategy</label>
          <select id="strategy">
            <option value="auto">Auto-detect (recommended)</option>
            <option value="comma">Comma / CSV-like</option>
            <option value="tab">Tab-delimited</option>
            <option value="spaces">Multiple spaces as delimiter</option>
          </select>

          <label for="pages">Pages to extract (e.g. 1,3-5) — leave empty for all</label>
          <input id="pages" placeholder="1,3-5" />

          <div class="controls">
            <button id="extractBtn" class="primary">Extract & Convert</button>
            <button id="previewBtn" class="alt">Preview Raw Text</button>
            <button id="clearBtn" class="alt">Clear</button>
          </div>

          <div class="meta">Note: This tool attempts to reconstruct tables from text positions. Complex layouts, merged cells, forms, or scanned PDFs (images) may not convert accurately. For scanned PDFs use OCR (not included here).</div>
        </div>

        <div>
          <label>Conversion Options</label>
          <div style="display:flex;gap:8px;margin-top:8px">
            <label style="flex:1"><input type="checkbox" id="oneSheetPerPage" checked /> One sheet per PDF page</label>
            <label style="flex:1"><input type="checkbox" id="trimCells" checked /> Trim cell whitespace</label>
          </div>

          <label style="margin-top:8px">Preview / Output</label>
          <pre id="preview">No output yet.</pre>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="downloadXlsx" class="alt">Download .xlsx</button>
            <button id="copyCsv" class="alt">Copy CSV</button>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 8px">Description</h2>
      <p style="margin:0;color:#374151;line-height:1.6">This PDF to Excel converter runs entirely in the browser. It extracts selectable text from the PDF and applies heuristics to detect rows and columns based on text vertical positions and spacing. The result is exported as .xlsx using SheetJS. Ideal for digital PDFs with clear tabular layouts (reports, exported tables, invoices).</p>
      <ul style="margin-top:8px;color:#374151">
        <li>Client-side conversion — no file upload to servers.</li>
        <li>Attempts auto-detection of delimiters and table structure.</li>
        <li>Options: one sheet per page, trim cells, specify pages.</li>
        <li>Limitations: scanned PDFs require OCR; complex layouts may need manual cleanup in Excel.</li>
      </ul>
    </div>
  </div>

  <script>
    const pdfFile = document.getElementById('pdfFile');
    const extractBtn = document.getElementById('extractBtn');
    const previewBtn = document.getElementById('previewBtn');
    const clearBtn = document.getElementById('clearBtn');
    const preview = document.getElementById('preview');
    const strategyEl = document.getElementById('strategy');
    const pagesEl = document.getElementById('pages');
    const oneSheetPerPageEl = document.getElementById('oneSheetPerPage');
    const trimCellsEl = document.getElementById('trimCells');
    const downloadXlsx = document.getElementById('downloadXlsx');
    const copyCsv = document.getElementById('copyCsv');

    let lastWorkbookBlob = null;
    let lastCsvText = '';

    function parsePagesInput(str, maxPage){
      if(!str) return null;
      const parts = str.split(',').map(s=>s.trim());
      const pages = new Set();
      parts.forEach(p => {
        if(p.includes('-')){
          const [a,b] = p.split('-').map(Number);
          if(!isNaN(a) && !isNaN(b)) for(let i=a;i<=b;i++) if(i>=1 && i<=maxPage) pages.add(i);
        } else {
          const n = Number(p); if(!isNaN(n) && n>=1 && n<=maxPage) pages.add(n);
        }
      });
      return Array.from(pages).sort((a,b)=>a-b);
    }

    // Heuristic: group text items by rounded Y position to form lines, then sort by X within line
    function pageTextItemsToRows(textItems){
      // textItems: array of {str, transform: [a,b,c,d,e,f]} - y is transform[5]
      const linesMap = new Map();
      textItems.forEach(it => {
        const y = Math.round(it.transform[5]); // approximate vertical position
        if(!linesMap.has(y)) linesMap.set(y, []);
        linesMap.get(y).push(it);
      });
      const ys = Array.from(linesMap.keys()).sort((a,b)=>b-a); // top-to-bottom (pdf coordinate)
      const rows = ys.map(y => {
        const arr = linesMap.get(y).sort((a,b)=>a.transform[4]-b.transform[4]); // x = transform[4]
        return arr.map(a=>a.str).join(' ').replace(/\s+/g,' ');
      });
      return rows.filter(r=>r.trim());
    }

    function splitRowToCells(row, strategy){
      if(strategy==='comma') return row.split(',');
      if(strategy==='tab') return row.split('\t');
      if(strategy==='spaces') return row.split(/\s{2,}/); // multiple spaces
      // auto: try comma, tab, then multiple spaces; fallback to single space split
      if(row.includes(',')) return row.split(',');
      if(row.includes('\t')) return row.split('\t');
      const multi = row.split(/\s{2,}/);
      if(multi.length>1) return multi;
      return row.split(/\s/);
    }

    async function extractAndConvert(){
      const file = pdfFile.files[0];
      if(!file) { alert('Please choose a PDF file first'); return; }
      preview.textContent = 'Reading PDF...';
      const arrayBuffer = await file.arrayBuffer();
      const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
      const pdf = await loadingTask.promise;
      const maxPage = pdf.numPages;
      const pagesToUse = parsePagesInput(pagesEl.value, maxPage) || Array.from({length:maxPage},(_,i)=>i+1);

      const wb = XLSX.utils.book_new();
      let allCsv = [];

      for(const p of pagesToUse){
        preview.textContent = `Extracting page ${p} of ${maxPage}...`;
        const page = await pdf.getPage(p);
        const textContent = await page.getTextContent();
        const rows = pageTextItemsToRows(textContent.items);
        // convert rows to 2D array
        const data = rows.map(r => splitRowToCells(r, strategyEl.value).map(c => trimCellsEl.checked ? c.trim() : c));
        if(data.length===0){
          // if no rows found, try merging lines by newline characters in strings
          const raw = textContent.items.map(i=>i.str).join('\n');
          const fallbackRows = raw.split('\n').map(r=>r.trim()).filter(Boolean);
          const fd = fallbackRows.map(r=>[r]);
          if(oneSheetPerPageEl.checked) XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(fd), `Page-${p}`);
          allCsv.push(...fallbackRows);
        } else {
          if(oneSheetPerPageEl.checked) XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(data), `Page-${p}`);
          else {
            // append to first sheet name 'Sheet1'
            const sheetName = 'Sheet1';
            let existing = wb.Sheets[sheetName];
            if(!existing){ XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(data), sheetName); }
            else {
              // merge: read existing to aoa, concat, then replace sheet
              const aoa = XLSX.utils.sheet_to_json(existing, {header:1});
              const merged = aoa.concat(data);
              wb.Sheets[sheetName] = XLSX.utils.aoa_to_sheet(merged);
            }
          }
          allCsv.push(...rows);
        }
      }

      // write workbook to blob and store for download
      const wbout = XLSX.write(wb, {bookType:'xlsx', type:'array'});
      lastWorkbookBlob = new Blob([wbout], {type:'application/octet-stream'});
      lastCsvText = allCsv.join('\n');

      preview.textContent = 'Conversion complete. Click Download .xlsx to save. Preview shows first 2000 characters:\n\n' + lastCsvText.slice(0,2000) + (lastCsvText.length>2000 ? '\n\n... (truncated)' : '');
    }

    extractBtn.addEventListener('click', async ()=>{
      try{ await extractAndConvert(); }catch(err){ console.error(err); alert('Extraction failed: '+err.message); }
    });

    previewBtn.addEventListener('click', async ()=>{
      const file = pdfFile.files[0];
      if(!file) return alert('Please choose a PDF file first');
      preview.textContent = 'Reading raw PDF text...';
      const arrayBuffer = await file.arrayBuffer();
      const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
      const pdf = await loadingTask.promise;
      let all = [];
      for(let p=1;p<=pdf.numPages;p++){
        const page = await pdf.getPage(p);
        const tc = await page.getTextContent();
        const rows = pageTextItemsToRows(tc.items);
        all.push(`--- Page ${p} ---\n` + rows.join('\n'));
      }
      preview.textContent = all.join('\n\n');
    });

    downloadXlsx.addEventListener('click', ()=>{
      if(!lastWorkbookBlob) return alert('No converted workbook available. Run Extract & Convert first.');
      const url = URL.createObjectURL(lastWorkbookBlob);
      const a = document.createElement('a'); a.href = url; a.download = 'converted.xlsx'; a.click(); URL.revokeObjectURL(url);
    });

    copyCsv.addEventListener('click', async ()=>{
      if(!lastCsvText) return alert('No CSV text available. Run Extract & Convert first.');
      try{ await navigator.clipboard.writeText(lastCsvText); alert('CSV copied to clipboard'); }catch(e){ alert('Copy failed — allow clipboard access'); }
    });

    clearBtn.addEventListener('click', ()=>{ pdfFile.value=''; preview.textContent=''; lastWorkbookBlob=null; lastCsvText=''; });
  </script>
</body>
</html>
