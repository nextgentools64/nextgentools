<!--
Filename Suggestion: tic-tac-toe.html
Description: A responsive, real-time multiplayer Tic-Tac-Toe game using HTML, CSS (Tailwind), and Firestore for turn-based synchronization. Includes FAQs.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Tic-Tac-Toe</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="A real-time, persistent multiplayer Tic-Tac-Toe game playable with any user using Google Firestore synchronization.">
    <meta name="keywords" content="tic-tac-toe, multiplayer, real-time game, firestore, html game">
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }
        .game-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 300px;
            height: 300px;
        }
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: 900;
            color: #374151;
            cursor: pointer;
            border: 2px solid #9ca3af;
            transition: background-color 0.2s;
        }
        .cell:hover:not(.occupied) {
            background-color: #e5e7eb;
        }
        .cell:nth-child(3n) { border-right: none; }
        .cell:nth-child(1), .cell:nth-child(2), .cell:nth-child(3) { border-top: none; }
        .cell:nth-last-child(1), .cell:nth-last-child(2), .cell:nth-last-child(3) { border-bottom: none; }
        .cell:nth-child(3n + 1) { border-left: none; }
        
        /* Specific Styles for X and O */
        .cell.x { color: #ef4444; } /* Red for X */
        .cell.o { color: #3b82f6; } /* Blue for O */

        /* Shine on winning cells */
        .cell.win {
            background-color: #d1fae5;
            animation: pulse-green 1s infinite;
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(16, 185, 129, 0); }
        }

    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-md mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-extrabold text-gray-800 mb-2">Multiplayer Tic-Tac-Toe</h1>
            <p id="userIdDisplay" class="text-xs text-indigo-600 font-medium tracking-wide border border-indigo-300 p-1 rounded-full inline-block bg-indigo-50">
                Your ID: Connecting...
            </p>
        </header>

        <!-- Game Card -->
        <div class="bg-white rounded-xl shadow-2xl p-6 border border-indigo-200 flex flex-col items-center">
            
            <!-- Game Status -->
            <div id="statusMessage" class="h-10 text-xl font-bold mb-4 text-center">Connecting to game...</div>
            <div id="loadingIndicator" class="text-gray-500 mb-4">
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-indigo-500 inline-block" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Waiting for real-time connection...
            </div>

            <!-- Game Board -->
            <div id="gameBoard" class="game-grid mb-6">
                <!-- Cells generated by JS -->
            </div>

            <!-- Game Actions -->
            <button 
                id="resetButton" 
                class="bg-indigo-500 text-white p-3 rounded-xl hover:bg-indigo-600 transition duration-150 font-medium shadow-lg disabled:opacity-50"
                disabled
            >
                Start New Game
            </button>
            
        </div>
        
        <!-- Documentation Section -->
        <div class="mt-8 p-6 bg-white rounded-xl shadow-lg border border-gray-200">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">How to Play Multiplayer Tic-Tac-Toe</h2>
            <p class="text-gray-600 mb-4">This is a persistent, real-time game. Any user connected shares the same game board and takes turns to play.</p>
            
            <h3 class="text-xl font-semibold text-gray-700 mb-3">Game Rules</h3>
            <ul class="list-disc list-inside space-y-2 text-gray-600 ml-4">
                <li>**Turns:** The game status shows whose turn it is (X or O). Only the current player can make a move.</li>
                <li>**Synchronization:** Every move you make is instantly saved and visible to all other players.</li>
                <li>**Player Roles:** The first user to join becomes 'X'. The second user becomes 'O'.</li>
                <li>**Winning:** The first player to get three of their marks (X or O) in a row (horizontal, vertical, or diagonal) wins!</li>
                <li>**Reset:** The **"Start New Game"** button resets the board for everyone, keeping the same player roles.</li>
            </ul>

            <h2 class="text-2xl font-bold text-gray-800 mt-8 mb-4 border-t pt-4">Frequently Asked Questions (FAQs)</h2>
            <div class="space-y-4">
                <div>
                    <h4 class="font-medium text-gray-800">1. How do I play with someone else?</h4>
                    <p class="text-sm text-gray-600">To play, simply share the URL of this page with a friend. When they open it, they will automatically join the same game. The first two users to connect will be assigned the 'X' and 'O' roles.</p>
                </div>
                <div>
                    <h4 class="font-medium text-gray-800">2. What happens if more than two people join?</h4>
                    <p class="text-sm text-gray-600">The game only allows two active players ('X' and 'O') at a time. All other users who join later will be able to watch the game unfold in real-time, but they will not be able to make moves.</p>
                </div>
                <div>
                    <h4 class="font-medium text-gray-800">3. Is the game state saved permanently?</h4>
                    <p class="text-sm text-gray-600">Yes. The current game board, player assignments, and turn status are all saved in **Google Firestore**. If you close the page and come back, the game will resume exactly where you left off until someone clicks "Start New Game."</p>
                </div>
            </div>
        </div>
        
        <!-- Footer -->
        <footer class="mt-8 text-center text-gray-500 text-sm">
            <p>Site Name: StoreDropship.in | Contact: +91 9258036351, contact@storedropship.in</p>
        </footer>
    </div>

    <!-- Firebase Configuration and Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, doc, onSnapshot, setDoc, getDoc, 
            setLogLevel 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('debug');

        // --- GLOBAL ENVIRONMENT VARIABLES ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // --- FIREBASE INSTANCES & STATE ---
        let db, auth;
        let userId = null;
        const GAME_DOC_ID = "current_tictactoe_game"; 
        
        // --- GAME STATE ---
        let game = {
            board: Array(9).fill(null),
            currentPlayer: 'X', // X always starts
            winner: null,
            players: {}, // { 'X': userId_of_X, 'O': userId_of_O }
            winningCombo: null
        };
        let isAuthReady = false;

        // --- DOM ELEMENTS ---
        const userIdDisplay = document.getElementById('userIdDisplay');
        const statusMessage = document.getElementById('statusMessage');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const gameBoardElement = document.getElementById('gameBoard');
        const resetButton = document.getElementById('resetButton');

        // --- WINNING COMBINATIONS ---
        const WINNING_COMBOS = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns
            [0, 4, 8], [2, 4, 6]             // Diagonals
        ];

        // --- FIREBASE INITIALIZATION AND AUTH ---

        async function initializeFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                userId = auth.currentUser?.uid || crypto.randomUUID();
                userIdDisplay.textContent = `Your ID: ${userId}`;
                isAuthReady = true;

                // CRITICAL STEP: Ensure the game document exists before proceeding
                await ensureGameDocumentExists();
                
                // Set up the real-time listener
                setupRealtimeListener();

            } catch (error) {
                console.error("Firebase Initialization Failed:", error);
                statusMessage.textContent = "Error connecting to service.";
                loadingIndicator.style.display = 'none';
            }
        }

        function getGameDocRef() {
            if (!db) return null;
            // Public data path: /artifacts/{appId}/public/data/games/current_tictactoe_game
            return doc(db, 'artifacts', appId, 'public', 'data', 'games', GAME_DOC_ID);
        }

        async function ensureGameDocumentExists() {
            const docRef = getGameDocRef();
            if (!docRef) return;
            
            try {
                const docSnap = await getDoc(docRef);
                if (!docSnap.exists()) {
                    // Initialize the game state if it doesn't exist
                    await setDoc(docRef, game, { merge: false });
                    console.log("Game document initialized in Firestore.");
                }
            } catch (error) {
                console.error("Error ensuring game document existence:", error);
            }
        }

        // --- REALTIME LISTENER ---

        function setupRealtimeListener() {
            const docRef = getGameDocRef();
            if (!docRef) return;

            onSnapshot(docRef, (docSnap) => {
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                resetButton.disabled = false;

                if (docSnap.exists()) {
                    // Update local game state
                    const serverGame = docSnap.data();
                    game = { ...game, ...serverGame }; // Merge server state into local state
                    
                    // Assign player role if necessary (only if the game is ongoing)
                    if (!game.winner) {
                        assignPlayerRole();
                    }
                    
                    // Update UI based on new game state
                    renderGame();
                }

            }, (error) => {
                console.error("Firestore real-time listener failed:", error);
                statusMessage.textContent = "Error loading real-time game data.";
            });
        }
        
        async function assignPlayerRole() {
            let shouldSave = false;

            // 1. Assign 'X' role
            if (!game.players['X']) {
                game.players['X'] = userId;
                shouldSave = true;
            } 
            
            // 2. Assign 'O' role (only if the current user is not X and O is empty)
            else if (game.players['X'] !== userId && !game.players['O']) {
                game.players['O'] = userId;
                shouldSave = true;
            }

            // 3. If a change was made, push the updated player list to Firestore
            if (shouldSave) {
                // Only update the 'players' field
                const docRef = getGameDocRef();
                if (docRef) {
                    try {
                        await setDoc(docRef, { players: game.players }, { merge: true });
                    } catch (error) {
                         console.error("Error saving player assignment:", error);
                    }
                }
            }
        }

        // --- GAME LOGIC ---

        function checkWinner(board) {
            for (const combo of WINNING_COMBOS) {
                const [a, b, c] = combo;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return { winner: board[a], combo: combo };
                }
            }
            if (board.every(cell => cell !== null)) {
                return { winner: 'Tie', combo: null };
            }
            return { winner: null, combo: null };
        }
        
        function handleCellClick(index) {
            if (!isAuthReady || game.winner || game.board[index] !== null) return;
            
            const playerRole = (game.players['X'] === userId) ? 'X' : (game.players['O'] === userId) ? 'O' : null;

            if (!playerRole) {
                statusMessage.textContent = "You are currently a spectator. Please wait for a player slot.";
                return;
            }
            
            if (playerRole !== game.currentPlayer) {
                statusMessage.textContent = `It's the other player's turn! (${game.currentPlayer})`;
                return;
            }

            // Execute move locally
            game.board[index] = playerRole;
            const result = checkWinner(game.board);

            if (result.winner) {
                game.winner = result.winner;
                // If it's a win or tie, the game ends, save the final state
                saveGame(result.combo); 
            } else {
                // Switch turn and save
                game.currentPlayer = (playerRole === 'X') ? 'O' : 'X';
                saveGame();
            }
        }

        async function saveGame(winningCombo = null) {
            const docRef = getGameDocRef();
            if (!docRef) return;
            
            const dataToSave = {
                board: game.board,
                currentPlayer: game.currentPlayer,
                winner: game.winner,
                players: game.players,
                winningCombo: winningCombo
            };

            try {
                await setDoc(docRef, dataToSave, { merge: false });
            } catch (error) {
                console.error("Error saving game state:", error);
            }
        }
        
        function resetGame() {
            const initialGame = {
                board: Array(9).fill(null),
                currentPlayer: 'X',
                winner: null,
                players: game.players || {}, // Keep current players assigned
                winningCombo: null
            };
            game = initialGame;
            saveGame();
        }
        
        // --- UI RENDERING ---

        function renderGame() {
            gameBoardElement.innerHTML = ''; // Clear board
            
            // Determine player's role
            let role = (game.players['X'] === userId) ? 'X' : (game.players['O'] === userId) ? 'O' : null;

            // Render Status Message
            if (game.winner === 'Tie') {
                statusMessage.textContent = "Game Over: It's a Tie!";
                statusMessage.className = 'h-10 text-xl font-bold mb-4 text-center text-gray-700';
            } else if (game.winner) {
                const winText = (game.winner === role) ? "You Win!" : `${game.winner} Wins!`;
                statusMessage.textContent = `Game Over: ${winText}`;
                statusMessage.className = 'h-10 text-xl font-bold mb-4 text-center text-green-600';
            } else if (!game.players['X'] || !game.players['O']) {
                const missingPlayer = !game.players['X'] ? 'X' : (!game.players['O'] && game.players['X'] !== userId) ? 'O' : 'Opponent';
                statusMessage.textContent = `Waiting for Player ${missingPlayer} to join...`;
                statusMessage.className = 'h-10 text-xl font-bold mb-4 text-center text-gray-500';
            } else if (game.currentPlayer === role) {
                statusMessage.textContent = "Your Turn! Make a Move.";
                statusMessage.className = 'h-10 text-xl font-bold mb-4 text-center text-indigo-600';
            } else {
                statusMessage.textContent = `Waiting for Player ${game.currentPlayer} to move...`;
                statusMessage.className = 'h-10 text-xl font-bold mb-4 text-center text-gray-700';
            }


            // Render Board Cells
            game.board.forEach((cell, index) => {
                const cellDiv = document.createElement('div');
                cellDiv.classList.add('cell');
                cellDiv.setAttribute('data-index', index);
                
                if (cell) {
                    cellDiv.classList.add('occupied', cell.toLowerCase());
                    cellDiv.textContent = cell;
                } else {
                    cellDiv.addEventListener('click', () => handleCellClick(index));
                }

                // Highlight winning cells
                if (game.winner && game.winningCombo && Array.isArray(game.winningCombo) && game.winningCombo.includes(index)) {
                    cellDiv.classList.add('win');
                }
                
                gameBoardElement.appendChild(cellDiv);
            });
        }
        
        // --- EVENT LISTENERS ---
        resetButton.addEventListener('click', resetGame);

        // Initialize Firebase on load
        window.onload = initializeFirebase;
    </script>
</body>
</html>