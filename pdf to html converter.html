<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF to HTML Converter — Storedropship</title>
  <meta name="description" content="Convert PDF to HTML in the browser. Extract selectable text and produce clean HTML with page breaks. Client-side, privacy-friendly tool." />
  <meta name="keywords" content="PDF to HTML, convert PDF to html, pdf.js, client-side converter, pdf extract text" />
  <style>
    :root{--bg:#f7fafc;--card:#fff;--muted:#6b7280;--accent:#0ea5a4}
    *{box-sizing:border-box;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif}
    body{margin:0;background:linear-gradient(180deg,var(--bg),#eef2ff);padding:18px;color:#0f172a}
    .wrap{max-width:1100px;margin:0 auto}
    .card{background:var(--card);padding:16px;border-radius:12px;box-shadow:0 8px 30px rgba(10,20,40,0.06);margin-bottom:14px}
    h1{margin:0 0 6px;font-size:20px}
    p.lead{margin:0 0 12px;color:var(--muted)}
    label{display:block;font-size:13px;color:#374151;margin-top:8px}
    input,select,button,textarea{width:100%;padding:10px;border-radius:8px;border:1px solid #e6eef6;font-size:14px}
    .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
    button.primary{background:var(--accent);color:#fff;border:none;padding:10px;border-radius:8px;cursor:pointer}
    button.alt{background:#fff;border:1px solid #e6eef6;color:#0b5394;padding:10px;border-radius:8px}
    pre{background:#f8fafc;padding:12px;border-radius:8px;border:1px solid #e6e9ef;overflow:auto;max-height:420px;white-space:pre-wrap}
    .meta{font-size:13px;color:var(--muted);margin-top:8px}
    .row{display:grid;grid-template-columns:1fr 420px;gap:12px}
    @media(max-width:900px){.row{grid-template-columns:1fr}}
  </style>
  <!-- PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>PDF to HTML Converter</h1>
      <p class="lead">Convert PDFs to simple, structured HTML in your browser. Extracts selectable text and builds an HTML document with page containers and basic styling. No server uploads — private and client-side.</p>

      <label for="pdfFile">Choose PDF file</label>
      <input id="pdfFile" type="file" accept="application/pdf" />

      <div class="row">
        <div>
          <label for="pages">Pages to extract (e.g. 1,3-5) — leave empty for all</label>
          <input id="pages" placeholder="1,3-5" />

          <label for="options">Options</label>
          <select id="options">
            <option value="simple">Simple HTML (text, paragraphs)</option>
            <option value="preserve">Preserve line breaks</option>
            <option value="divs">Page <code>&lt;div&gt;</code> with inline spans (positioning not exact)</option>
          </select>

          <div class="controls">
            <button id="extractBtn" class="primary">Extract & Build HTML</button>
            <button id="previewBtn" class="alt">Preview Raw Text</button>
            <button id="clearBtn" class="alt">Clear</button>
          </div>

          <div class="meta">Note: This extractor grabs selectable text. Images, complex layout, forms and scanned PDFs (images) are not reconstructed. For scanned PDFs use OCR (Tesseract.js) — placeholder available.</div>
        </div>

        <div>
          <label>Preview / Generated HTML</label>
          <pre id="preview">No output yet.</pre>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="downloadHtml" class="alt">Download HTML</button>
            <button id="copyHtml" class="alt">Copy HTML</button>
            <button id="openHtml" class="alt">Open HTML (new tab)</button>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Description</h2>
      <p style="margin:0;color:#374151;line-height:1.6">This PDF→HTML converter uses PDF.js to extract textual content and generate a usable HTML file. It is ideal for converting text-heavy PDFs (reports, articles) into editable HTML. The output is basic and intended for further cleanup in an editor if you need precise layout reproduction.</p>
      <ul style="margin-top:8px;color:#374151">
        <li>Client-side conversion — privacy friendly.</li>
        <li>Options to preserve line breaks or produce simpler paragraphs.</li>
        <li>Download, copy, or open the generated HTML in a new tab.</li>
        <li>Limitations: scanned PDFs need OCR; no pixel-perfect layout reconstruction.</li>
      </ul>
    </div>
  </div>

  <script>
    const pdfFile = document.getElementById('pdfFile');
    const extractBtn = document.getElementById('extractBtn');
    const previewBtn = document.getElementById('previewBtn');
    const clearBtn = document.getElementById('clearBtn');
    const preview = document.getElementById('preview');
    const optionsEl = document.getElementById('options');
    const pagesEl = document.getElementById('pages');
    const downloadHtml = document.getElementById('downloadHtml');
    const copyHtml = document.getElementById('copyHtml');
    const openHtml = document.getElementById('openHtml');

    let lastHtml = null; let lastDocName = 'converted';

    function parsePagesInput(str, maxPage){
      if(!str) return null;
      const parts = str.split(',').map(s=>s.trim());
      const pages = new Set();
      parts.forEach(p => {
        if(p.includes('-')){
          const [a,b] = p.split('-').map(Number);
          if(!isNaN(a) && !isNaN(b)) for(let i=a;i<=b;i++) if(i>=1 && i<=maxPage) pages.add(i);
        } else {
          const n = Number(p); if(!isNaN(n) && n>=1 && n<=maxPage) pages.add(n);
        }
      });
      return Array.from(pages).sort((a,b)=>a-b);
    }

    function pageTextItemsToLines(textItems){
      // Group by Y position
      const linesMap = new Map();
      textItems.forEach(it => {
        const y = Math.round((it.transform && it.transform[5]) ? it.transform[5] : (it.ty || 0));
        const key = Math.round(y/3)*3;
        if(!linesMap.has(key)) linesMap.set(key, []);
        linesMap.get(key).push(it);
      });
      const ys = Array.from(linesMap.keys()).sort((a,b)=>b-a);
      const lines = ys.map(y => {
        const arr = linesMap.get(y).sort((a,b)=>{
          const ax = (a.transform && a.transform[4]) ? a.transform[4] : (a.x || 0);
          const bx = (b.transform && b.transform[4]) ? b.transform[4] : (b.x || 0);
          return ax - bx;
        });
        return arr.map(a=>a.str).join(' ').replace(/\s+/g,' ').trim();
      });
      return lines.filter(l=>l);
    }

    function buildSimpleHTML(pages){
      // pages: [{page:number, lines: [...] }]
      const parts = [];
      parts.push('<!doctype html>');
      parts.push('<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Converted PDF</title>');
      parts.push('<style>body{font-family:system-ui,Segoe UI,Arial,sans-serif;padding:20px;color:#111} .page{page-break-after:always;margin-bottom:30px;border-bottom:1px solid #eee;padding-bottom:20px} .page h2{margin-top:0}</style>');
      parts.push('</head><body>');
      pages.forEach(p => {
        parts.push(`<div class="page" data-page="${p.page}"><h2>Page ${p.page}</h2>`);
        // join lines into paragraphs: blank line detection not available, so create p per 3-5 lines
        if(optionsEl.value==='preserve'){
          p.lines.forEach(line => parts.push('<p>'+escapeHtml(line)+'</p>'));
        } else {
          // group every 4 lines into a paragraph for readability
          for(let i=0;i<p.lines.length;i+=4){
            const grp = p.lines.slice(i,i+4).join(' ');
            parts.push('<p>'+escapeHtml(grp)+'</p>');
          }
        }
        parts.push('</div>');
      });
      parts.push('</body></html>');
      return parts.join('\n');
    }

    function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    async function extractAndBuild(){
      const file = pdfFile.files[0];
      if(!file) { alert('Please choose a PDF file first'); return; }
      lastDocName = file.name ? file.name.replace(/\.[^.]+$/, '') : 'converted';
      preview.textContent = 'Reading PDF...';
      const arrayBuffer = await file.arrayBuffer();
      const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
      const pdf = await loadingTask.promise;
      const maxPage = pdf.numPages;
      const pagesToUse = parsePagesInput(pagesEl.value, maxPage) || Array.from({length:maxPage},(_,i)=>i+1);

      const pages = [];
      for(const p of pagesToUse){
        preview.textContent = `Extracting page ${p} of ${maxPage}...`;
        const page = await pdf.getPage(p);
        const textContent = await page.getTextContent();
        const lines = pageTextItemsToLines(textContent.items);
        pages.push({page: p, lines});
      }

      const html = buildSimpleHTML(pages);
      lastHtml = html;
      preview.textContent = html.slice(0,20000) + (html.length>20000 ? '\n\n... (truncated)' : '');
    }

    extractBtn.addEventListener('click', async ()=>{
      try{ await extractAndBuild(); }catch(err){ console.error(err); alert('Extraction failed: '+err.message); }
    });

    previewBtn.addEventListener('click', async ()=>{
      const file = pdfFile.files[0];
      if(!file) return alert('Please choose a PDF file first');
      preview.textContent = 'Reading raw PDF text...';
      const arrayBuffer = await file.arrayBuffer();
      const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
      const pdf = await loadingTask.promise;
      let all = [];
      for(let p=1;p<=pdf.numPages;p++){
        const page = await pdf.getPage(p);
        const tc = await page.getTextContent();
        const lines = pageTextItemsToLines(tc.items);
        all.push(`--- Page ${p} ---\n` + lines.join('\n'));
      }
      preview.textContent = all.join('\n\n');
    });

    downloadHtml.addEventListener('click', ()=>{
      if(!lastHtml) return alert('No HTML available. Run Extract & Build first.');
      const blob = new Blob([lastHtml], {type:'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = lastDocName + '.html'; a.click(); URL.revokeObjectURL(url);
    });

    copyHtml.addEventListener('click', async ()=>{
      if(!lastHtml) return alert('No HTML available. Run Extract & Build first.');
      try{ await navigator.clipboard.writeText(lastHtml); alert('HTML copied to clipboard'); }catch(e){ alert('Copy failed — allow clipboard access'); }
    });

    openHtml.addEventListener('click', ()=>{
      if(!lastHtml) return alert('No HTML available. Run Extract & Build first.');
      const blob = new Blob([lastHtml], {type:'text/html'});
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank'); setTimeout(()=>URL.revokeObjectURL(url),2000);
    });

    clearBtn.addEventListener('click', ()=>{ pdfFile.value=''; preview.textContent=''; lastHtml=null; });
  </script>
</body>
</html>
