<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF to CSV Converter — Storedropship</title>
  <meta name="description" content="Convert PDF pages or tables into CSV format in the browser. Extract selectable text from PDFs and export as CSV. Best for digital PDFs with tabular layouts." />
  <meta name="keywords" content="PDF to CSV, convert PDF to csv, extract table from PDF, PDF text extraction, client-side PDF converter" />
  <style>
    :root{--bg:#f7fafc;--card:#fff;--muted:#64748b;--accent:#0ea5a4}
    *{box-sizing:border-box;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif}
    body{margin:0;background:linear-gradient(180deg,var(--bg),#eef2ff);padding:18px;color:#0f172a}
    .wrap{max-width:1100px;margin:0 auto}
    .card{background:var(--card);padding:16px;border-radius:12px;box-shadow:0 8px 30px rgba(10,20,40,0.06);margin-bottom:14px}
    h1{margin:0 0 6px;font-size:20px}
    p.lead{margin:0 0 12px;color:var(--muted)}
    label{display:block;font-size:13px;color:#374151;margin-top:8px}
    input,select,button,textarea{width:100%;padding:10px;border-radius:8px;border:1px solid #e6eef6;font-size:14px}
    .controls{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
    button.primary{background:var(--accent);color:#fff;border:none;padding:10px;border-radius:8px;cursor:pointer}
    button.alt{background:#fff;border:1px solid #e6eef6;color:#0b5394;padding:10px;border-radius:8px}
    pre{background:#f8fafc;padding:12px;border-radius:8px;border:1px solid #e6e9ef;overflow:auto;max-height:420px;white-space:pre-wrap}
    .meta{font-size:13px;color:var(--muted);margin-top:8px}
    .row{display:grid;grid-template-columns:1fr 420px;gap:12px}
    @media(max-width:900px){.row{grid-template-columns:1fr}}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>PDF to CSV Converter</h1>
      <p class="lead">Extract text from PDF pages and convert detected rows/columns into CSV. Runs entirely in your browser — no uploads. Best for digital (selectable-text) PDFs with tabular data.</p>

      <label for="pdfFile">Choose PDF file</label>
      <input id="pdfFile" type="file" accept="application/pdf" />

      <div class="row">
        <div>
          <label for="strategy">Parsing strategy</label>
          <select id="strategy">
            <option value="auto">Auto-detect (comma / tab / spaces)</option>
            <option value="comma">Comma-separated</option>
            <option value="tab">Tab-delimited</option>
            <option value="spaces">Multiple spaces as delimiter</option>
          </select>

          <label for="pages">Pages (e.g. 1,3-5). Leave blank = all pages</label>
          <input id="pages" placeholder="1,3-5" />

          <label for="delimiter">CSV delimiter (will be used for output)</label>
          <input id="delimiter" value="," />

          <div class="controls">
            <button id="extractBtn" class="primary">Extract & Convert</button>
            <button id="previewBtn" class="alt">Preview Raw Text</button>
            <button id="clearBtn" class="alt">Clear</button>
          </div>

          <div class="meta">Tip: This tool extracts text positions and groups text by approximate vertical position to reconstruct rows. For scanned PDFs use an OCR workflow.</div>
        </div>

        <div>
          <label>Preview / CSV Output</label>
          <pre id="preview">No output yet.</pre>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="downloadCsv" class="alt">Download CSV</button>
            <button id="copyCsv" class="alt">Copy CSV</button>
            <button id="openInSpreadsheet" class="alt">Open CSV (new tab)</button>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2 style="margin:0 0 8px">Description</h2>
      <p style="margin:0;color:#374151;line-height:1.6">This PDF→CSV converter uses PDF.js to read selectable text items and attempts to rebuild table-like rows using text Y positions and spacing heuristics. It is privacy-friendly (client-side) and useful for extracting simple tables, reports, invoices, or exported tables from PDFs.</p>
      <ul style="margin-top:8px;color:#374151">
        <li>Client-side conversion — files never leave your browser.</li>
        <li>Parsing strategies: auto, comma, tab, multiple spaces.</li>
        <li>Specify pages to extract and choose output delimiter.</li>
        <li>Limitations: scanned images need OCR; complex layouts may need manual cleanup.</li>
      </ul>
    </div>
  </div>

  <script>
    const pdfFile = document.getElementById('pdfFile');
    const extractBtn = document.getElementById('extractBtn');
    const previewBtn = document.getElementById('previewBtn');
    const clearBtn = document.getElementById('clearBtn');
    const preview = document.getElementById('preview');
    const strategyEl = document.getElementById('strategy');
    const pagesEl = document.getElementById('pages');
    const delimiterEl = document.getElementById('delimiter');
    const downloadCsv = document.getElementById('downloadCsv');
    const copyCsv = document.getElementById('copyCsv');
    const openInSpreadsheet = document.getElementById('openInSpreadsheet');

    let lastCsv = '';

    function parsePagesInput(str, maxPage){
      if(!str) return null;
      const parts = str.split(',').map(s=>s.trim());
      const pages = new Set();
      parts.forEach(p => {
        if(p.includes('-')){
          const [a,b] = p.split('-').map(Number);
          if(!isNaN(a) && !isNaN(b)) for(let i=a;i<=b;i++) if(i>=1 && i<=maxPage) pages.add(i);
        } else {
          const n = Number(p); if(!isNaN(n) && n>=1 && n<=maxPage) pages.add(n);
        }
      });
      return Array.from(pages).sort((a,b)=>a-b);
    }

    function pageTextItemsToRows(textItems){
      // group by rounded Y position (pdf coords use transform[5])
      const linesMap = new Map();
      textItems.forEach(it => {
        // some builds provide transform as array [a,b,c,d,e,f]
        const y = Math.round((it.transform && it.transform[5]) ? it.transform[5] : (it.ty || 0));
        // normalize y by rounding to nearest 3 pixels to merge small differences
        const key = Math.round(y/3)*3;
        if(!linesMap.has(key)) linesMap.set(key, []);
        linesMap.get(key).push(it);
      });
      const ys = Array.from(linesMap.keys()).sort((a,b)=>b-a); // top->bottom
      const rows = ys.map(y => {
        const arr = linesMap.get(y).sort((a,b)=>{
          const ax = (a.transform && a.transform[4]) ? a.transform[4] : (a.x || 0);
          const bx = (b.transform && b.transform[4]) ? b.transform[4] : (b.x || 0);
          return ax - bx;
        });
        return arr.map(a=>a.str).join(' ').replace(/\s+/g,' ').trim();
      });
      return rows.filter(r=>r);
    }

    function splitRowToCells(row, strategy){
      if(strategy==='comma') return row.split(',');
      if(strategy==='tab') return row.split('\t');
      if(strategy==='spaces') return row.split(/\s{2,}/);
      // auto
      if(row.includes(',')) return row.split(',');
      if(row.includes('\t')) return row.split('\t');
      const multi = row.split(/\s{2,}/);
      if(multi.length>1) return multi;
      return row.split(/\s/);
    }

    async function extractAndConvert(){
      const file = pdfFile.files[0];
      if(!file){ alert('Choose a PDF file first'); return; }
      preview.textContent = 'Reading PDF...';
      const arrayBuffer = await file.arrayBuffer();
      const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
      const pdf = await loadingTask.promise;
      const maxPage = pdf.numPages;
      const pagesToUse = parsePagesInput(pagesEl.value, maxPage) || Array.from({length:maxPage},(_,i)=>i+1);

      const allRows = [];
      for(const p of pagesToUse){
        preview.textContent = `Extracting page ${p} of ${maxPage}...`;
        const page = await pdf.getPage(p);
        const textContent = await page.getTextContent();
        const rows = pageTextItemsToRows(textContent.items);
        // convert rows to arrays
        const strategy = strategyEl.value;
        const rowsCells = rows.map(r => splitRowToCells(r, strategy).map(c => c.trim()));
        // append page-break marker as comment row
        allRows.push([`--- Page ${p} ---`]);
        allRows.push(...rowsCells);
      }

      // build CSV using chosen delimiter
      const delim = delimiterEl.value || ',';
      const csvLines = allRows.map(row => row.map(cell => {
        // escape delim and quotes
        if(cell == null) cell = '';
        const needsQuotes = cell.includes(delim) || cell.includes('"') || cell.includes('\n');
        let out = String(cell).replace(/"/g,'""');
        if(needsQuotes) out = '"' + out + '"';
        return out;
      }).join(delim));

      lastCsv = csvLines.join('\n');
      preview.textContent = lastCsv.slice(0,3000) + (lastCsv.length>3000 ? '\n\n... (truncated)' : '');
    }

    extractBtn.addEventListener('click', async ()=>{
      try{ await extractAndConvert(); }catch(err){ console.error(err); alert('Extraction failed: '+err.message); }
    });

    previewBtn.addEventListener('click', async ()=>{
      const file = pdfFile.files[0];
      if(!file) return alert('Please choose a PDF file first');
      preview.textContent = 'Reading raw PDF text...';
      const arrayBuffer = await file.arrayBuffer();
      const loadingTask = pdfjsLib.getDocument({data: arrayBuffer});
      const pdf = await loadingTask.promise;
      let all = [];
      for(let p=1;p<=pdf.numPages;p++){
        const page = await pdf.getPage(p);
        const tc = await page.getTextContent();
        const rows = pageTextItemsToRows(tc.items);
        all.push(`--- Page ${p} ---\n` + rows.join('\n'));
      }
      preview.textContent = all.join('\n\n');
    });

    downloadCsv.addEventListener('click', ()=>{
      if(!lastCsv) return alert('No CSV available. Run Extract & Convert first.');
      const blob = new Blob([lastCsv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'converted.csv'; a.click(); URL.revokeObjectURL(url);
    });

    copyCsv.addEventListener('click', async ()=>{
      if(!lastCsv) return alert('No CSV available. Run Extract & Convert first.');
      try{ await navigator.clipboard.writeText(lastCsv); alert('CSV copied to clipboard'); }catch(e){ alert('Copy failed — allow clipboard access'); }
    });

    openInSpreadsheet.addEventListener('click', ()=>{
      if(!lastCsv) return alert('No CSV available. Run Extract & Convert first.');
      const blob = new Blob([lastCsv], {type: 'text/csv'});
      const url = URL.createObjectURL(blob);
      // open in new tab - browser may display as text or download; user can open with spreadsheet
      window.open(url, '_blank');
      setTimeout(()=>URL.revokeObjectURL(url), 2000);
    });

    clearBtn.addEventListener('click', ()=>{ pdfFile.value=''; preview.textContent=''; lastCsv=''; });

    // init
    let lastCsv = '';
  </script>
</body>
</html>
